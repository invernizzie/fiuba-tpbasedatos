\documentclass[12pt,a4paper,spanish]{article} 
\usepackage{babel}
\usepackage [T1]{fontenc}
\usepackage [latin1]{inputenc}
\usepackage{graphicx} 
\usepackage{verbatim}
\usepackage{array}
	  \oddsidemargin 0in
      \textwidth 6.75in
      \topmargin 0in
      \textheight 10.0in
      \parindent 0em
      \parskip 2ex
\usepackage{anysize}
\marginsize{3cm}{2cm}{1.0cm}{1.0cm}

\pagestyle{plain}

\begin{document} 
\title{
\begin{table}[!h]
	\begin{tabular}{m{2cm}m{15cm}}
		\multicolumn{1}{l}{} &
		% \includegraphics[scale=0.5, bb=0 0 0 0]{logo-fiuba.PNG} & 
		 \begin{center}
		 	\begin{LARGE}
				Universidad de Buenos Aires	\linebreak \linebreak		 							Facultad de Ingenier\'{i}a  \linebreak \linebreak
				7515 - Base de Datos \linebreak \linebreak
				1er. Cuatrimestre de 2010
			\end{LARGE}
		 \end{center}\\
\end{tabular}
\end{table}
\begin{Large}
 \begin{center}
		\underline{TP Base de Datos: SIGeek} \linebreak \linebreak
        Docente a cargo: Ing. Lucas Roman
\end{center}
\end{Large}
}
\date{}
\maketitle

\thispagestyle{empty}
\author{
\begin{Large}
\begin{center}
		\underline{Integrantes}  \linebreak 
\end{center}
\end{Large}
\begin{center}
	\begin{tabular}{|| c | c | c ||}
		\hline
		\begin{large}Apellido y Nombre\end{large} & 
		\begin{large}Padr\'{o}n Nro.\end{large} & 
		\begin{large}E-mail\end{large}\\
		\hline
		Bruno Tomás & 88.449 & tbruno88@gmail.com\\
		\hline
		Invernizzi Esteban Ignacio & 88.817 & invernizzie@gmail.com\\
		\hline
		Meller Gustavo Ariel  & 88.435 & gmeller@gmail.com\\
		\hline
		Rivero Hern\'an Javier & 88.455 & riverohernanj@gmail.com\\
		\hline
	\end{tabular}
\end{center}
}

\newpage
\setcounter{page}{1} 
\tableofcontents
\newpage

\section{Introducción}

	Esta segunda entrega consta de la resolución y la expresión en lenguaje SQL de once consultas, contra un esquema relacional propuesto por la cátedra. Las sentencias y cláusulas a utilizar fueron restringidas a las presentadas por la cátedra en la cartilla del apunte del lenguaje SQL.

\section{Consultas y resolución}
	
	\begin{itemize}
	
		\item[Consulta 1] El promedio de mothers pedidas por pedido.\\
		\begin{verbatim}
Select sum(CANT_PEDIDA) / (count(distinct PEDIDO.NRO_PEDIDO) * count(distinct PEDIDO.NRO_PEDIDO))
From PEDIDO, ITEM_PEDIDO, SUBTIPO_COMPONENTE
Where ITEM_PEDIDO.SUBTIPO = SUBTIPO_COMPONENTE.SUBTIPO
  And TIPO = 'MOTHER'
		\end{verbatim}
		
		\item[Consulta 2] La razón social de los proveedores tales que existe un producto
que no comercializan.\\
		\begin{verbatim}
Select RAZON_SOCIAL
From PROVEEDOR pr1
Where exists (Select * From TIPO_COMPONENTE
              Where not exists (Select * From CATALOGO_PROVEEDOR, SUBTIPO_COMPONENTE
                                Where CATALOGO_PROVEEDOR.SUBTIPO = SUBTIPO_COMPONENTE.SUBTIPO
                                  And pr1.CUIT = CATALOGO_PROVEEDOR.CUIT
                                  And SUBTIPO_COMPONENTE.TIPO = TIPO_COMPONENTE.TIPO) )
		\end{verbatim}
		
		\item[Consulta 3] Un listado alfabético de subtipos de componentes a reponer indicando tipo de componente, subtipo de componente y razon$\_$social de los proveedores que los comercializan.\\
		\begin{verbatim}
		
		SELECT TIPO,  S.SUBTIPO, RAZON_SOCIAL
		FROM SUBTIPO_COMPONENTE S, CATALOGO_PROVEEDOR C, PROVEEDOR P
		WHERE S.SUBTIPO = C.SUBTIPO AND C.CUIT = P. CUIT AND CANT_STOCK < CANT_MINIMA
		ORDER BY TIPO, SUBTIPO

		\end{verbatim}
		
		\item[Consulta 4] La razon$\_$social de los proveedores que comercializan todos los subtipos de componentes a reponer.
		\begin{verbatim}
		
		SELECT RAZON_SOCIAL
		FROM PROVEEDOR P
		WHERE NOT EXISTS (
			SELECT 'SUBTIPO A REPONER NO COMECIALIZADO'
			FROM SUBTIPO_COMPONENTE S	
			WHERE CANT_STOCK < CANT_MINIMA AND NOT EXISTS(
				SELECT 'SUBTIPO EN CATALOGO'
				FROM CATALOGO_PROVEEDOR C
				WHERE P.CUIT = C.CUIT AND S.SUBTIPO = C.SUBTIPO))

		\end{verbatim}
		
		\item[Consulta 5] La razon$\_$social, el nro$\_$pedido y el subtipo de componente de los ítems de pedidos de subtipos de componente no comercializados por el proveedor del pedido.
		\begin{verbatim}
		
		SELECT RAZON_SOCIAL, PE.NRO_PEDIDO, SUBTIPO
		FROM PROVEEDOR PR, PEDIDO PE, ITEM_PEDIDO I
		WHERE PR.CUIT = PE.CUIT AND PE.NRO_PEDIDO = I.NRO_PEDIDO
		AND I.SUBTIPO NOT IN (
			SELECT SUBTIPO
			FROM CATALOGO_PROVEEDOR C
			WHERE C.CUIT = PR. CUIT) 

		\end{verbatim}
		
		\item[Consulta 6] La razon$\_$social de los proveedores que comercializan exclusivamente un tipo de componente.
		Lo que entiendo: La razon social de los proveedores que tienen en su catalogo un tipo de componente que no esta en el catalogo de ningún otro proveedor.
		\begin{verbatim}
select P.RAZON_SOCIAL
from PROVEEDOR P, CATALOGO_PROVEEDOR CP, SUBTIPO_COMPONENTE S
where P.CUIT = CP.CUIT
and CP.SUBTIPO = S.SUBTIPO
and not exists(
				select *
				from PROVEEDOR P2, CATALOGO_PROVEEDOR CP2, SUBTIPO_COMPONENTE S2
				where P2.CUIT = CP2.CUIT
				and CP2.SUBTIPO = S2.SUBTIPO
				and P.CUIT <> P2.CUIT
				and S.TIPO = S2.TIPO)
		\end{verbatim}
		Resultado:
		RAZON_SOCIAL
		Distecna S.A.		

		\item[Consulta 7] El subtipo de los componentes entregados exclusivamente por el proveedor 'Ceven S.A.'.
				Si lo que pregunta es sobre si los subtipos que puede pedir entonces:
	
		\begin{verbatim}
SELECT sub.subtipo
FROM  subtipo_componente sub
WHERE sub.subtipo in 
					( 	SELECT sub.subtipo
						FROM subtipo_componente sub, catalogo_proveedor cat, proveedor prov
						WHERE sub.subtipo=cat.subtipo and cat.cuit=prov.cuit and prov.razon_social='Ceven S.A.'
					)
			  and
	 sub.subtipo not in
					( 	SELECT sub.subtipo
						FROM subtipo_componente sub, catalogo_proveedor cat, proveedor prov
						WHERE sub.subtipo=cat.subtipo and cat.cuit=prov.cuit and not prov.razon_social='Ceven S.A'
					)
		
Si lo que pregunta es sobre lo que efectivamente se pidio, entonces:
		\end{verbatim}
		\begin{verbatim}		
SELECT sub.subtipo
FROM  subtipo_componente sub
WHERE sub.subtipo in 
					( 	SELECT sub.subtipo
						FROM subtipo_componente sub,  proveedor prov, pedido ped, item_pedido item
						WHERE sub.subtipo=item.subtipo 
							and ped.nro_pedido=item.nro_pedido 
							and ped.cuit=prov.cuit 
							and prov.razon_social='Ceven S.A.'
					)
			  and
	 sub.subtipo not in
					( 	SELECT sub.subtipo
						FROM subtipo_componente sub,  proveedor prov, pedido ped, item_pedido item
						WHERE sub.subtipo=item.subtipo 
							and ped.nro_pedido=item.nro_pedido 
							and ped.cuit=prov.cuit 
							and not prov.razon_social='Ceven S.A.'
					)		
		\end{verbatim}
		\item[Consulta 8] El subtipo de los componentes para los cuales el stock informado es distinto del real.
		
		Hipotesis: los componentes que existen, no son utilizados en pcs y no estan reservadas para ordenes, forman parte del stock.
		
		\begin{verbatim}

SELECT sub.subtipo
FROM subtipo_componente sub
WHERE not sub.cant_stock=(
						SELECT count(*)
						FROM componente comp
						WHERE sub.subtipo=comp.subtipo
								and  comp.codigo_pc IS NULL
								and  comp.nro_orden IS NULL				
						)
						
		\end{verbatim}
		
		\item[Consulta 9] El nro$\_$pedido y el subtipo de componentes de los ítems de pedidos cuya cantidad pedida supere a la cantidad pedida promedio de ese subtipo de componentes.
		\begin{verbatim}
SELECT item.nro_pedido, item.subtipo
FROM item_pedido item
WHERE item.cant_pedida>( 
					SELECT avg(item2.cant_pedida)
					FROM item_pedido item2
					WHERE item2.subtipo=item.subtipo
				   )
		\end{verbatim}
		
		\item[Consulta 10] Para cada tipo de componente el subtipo de componente que tenga la mayor cantidad recibida.
		Lo que entiendo: por cada tipo de componente que haya tengo que mostrar el subtipo que tenga la mayor cantidad recibida.
		Busco para cada tipo el maximo recibido y despues lo uso como una tabla para buscar el subtipo que tenga esa cantidad.
		\begin{verbatim}
select T.TIPO, S.SUBTIPO
from TIPO_COMPONENTE T, SUBTIPO_COMPONENTE S, ITEM_PEDIDO I, (	select T2.TIPO, max(I2.CANT_RECIBIDA) MAX_CANT
								from TIPO_COMPONENTE T2, SUBTIPO_COMPONENTE S2, ITEM_PEDIDO I2
								where T2.TIPO = S2.TIPO
								and S2.SUBTIPO = I2.SUBTIPO
								group by T2.TIPO) C
where T.TIPO = S.TIPO
and C.TIPO = T.TIPO
and I.SUBTIPO = S.SUBTIPO
and I.CANT_RECIBIDA = C.MAX_CANT		
		\end{verbatim}
		Resultado
		TIPO	SUBTIPO
		MOTHER	GIGABYTE GA-H55M-UD2H
		DVD-RW	SAMSUNG 58X SATAII
		PLACAS VIDEO	XFX ATI 5700 1GB DDR5
		MEMORIA RAM	KINGSTON DD3 1066 1GB
		HDD	WD WD5001AALS
		CPU	INTEL I5-540M
		
		\item[Consulta 11] El subtipo de los componentes entregados por todos los proveedores que comercializan todos los tipos de componentes.
		\begin{verbatim}
		
		SELECT SUBTIPO
		FROM SUBTIPO_COMPONENTE S1
		WHERE NOT EXISTS(
			SELECT 'PROVEDOR DE TODOS LOS TIPOS QUE NO LO ENTREGA'
			FROM PROVEEDOR P
			WHERE NOT EXISTS(
				SELECT 'TIPO NO ENTREGADO'
				FROM TIPO_COMPONENTE T
				WHERE NOT EXISTS (
					SELECT 'TIPO EN CATALOGO'
					FROM SUBTIPO_COMPONENTE S2, CATALOGO_PROVEEDOR C1
					WHERE S2.TIPO = T.TIPO AND C1.CUIT = P.CUIT AND C1.SUBTIPO =S2.SUBTIPO))
				AND P.CUIT NOT IN (
					SELECT C2.CUIT
					FROM CATALOGO_PROVEEDOR C2
					WHERE S1.SUBTIPO = C2.SUBTIPO))

		\end{verbatim}
		
	\end{itemize}

   

\end{document}
